一、接口说明
中英识别大模型识别能力，将短音频(≤60秒)精准识别成文字，实时返回文字结果，真实还原语音内容。支持中文、英文及202种方言免切换识别。

二、接口Demo
# -*- coding:utf-8 -*-
#
#   author: iflytek
#
#  本demo测试时运行的环境为：Windows + Python3.7
#  本demo测试成功运行时所安装的第三方库及其版本如下，您可自行逐一或者复制到一个新的txt文件利用pip一次性安装：
#   cffi==1.12.3
#   gevent==1.4.0
#   greenlet==0.4.15
#   pycparser==2.19
#   six==1.12.0
#   websocket==0.2.1
#   websocket-client==0.56.0
#
#  语音听写流式 WebAPI 接口调用示例 接口文档（必看）：https://doc.xfyun.cn/rest_api/语音听写（流式版）.html
#  webapi 听写服务参考帖子（必看）：http://bbs.xfyun.cn/forum.php?mod=viewthread&tid=38947&extra=
#  语音听写流式WebAPI 服务，热词使用方式：登陆开放平台https://www.xfyun.cn/后，找到控制台--我的应用---语音听写（流式）---服务管理--个性化热词，
#  设置热词
#  注意：热词只能在识别的时候会增加热词的识别权重，需要注意的是增加相应词条的识别率，但并不是绝对的，具体效果以您测试为准。
#  语音听写流式WebAPI 服务，方言试用方法：登陆开放平台https://www.xfyun.cn/后，找到控制台--我的应用---语音听写（流式）---服务管理--识别语种列表
#  可添加语种或方言，添加后会显示该方言的参数值
#  错误码链接：https://www.xfyun.cn/document/error-code （code返回错误码时必看）
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
import _thread as thread
import time
from time import mktime

import websocket

import base64
import datetime
import hashlib
import hmac
import json
import ssl
from datetime import datetime
from urllib.parse import urlencode
from wsgiref.handlers import format_date_time

STATUS_FIRST_FRAME = 0  # 第一帧的标识
STATUS_CONTINUE_FRAME = 1  # 中间帧标识
STATUS_LAST_FRAME = 2  # 最后一帧的标识


class Ws_Param(object):
    # 初始化
    def __init__(self, APPID, APIKey, APISecret, AudioFile):
        self.APPID = APPID
        self.APIKey = APIKey
        self.APISecret = APISecret
        self.AudioFile = AudioFile
        self.iat_params = {
            "domain": "slm", "language": "zh_cn", "accent": "mandarin","dwa":"wpgs", "result":
                {
                    "encoding": "utf8",
                    "compress": "raw",
                    "format": "plain"
                }
        }

    # 生成url
    def create_url(self):
        url = 'ws://iat.xf-yun.com/v1'
        # 生成RFC1123格式的时间戳
        now = datetime.now()
        date = format_date_time(mktime(now.timetuple()))

        # 拼接字符串
        signature_origin = "host: " + "iat.xf-yun.com" + "\n"
        signature_origin += "date: " + date + "\n"
        signature_origin += "GET " + "/v1 " + "HTTP/1.1"
        # 进行hmac-sha256进行加密
        signature_sha = hmac.new(self.APISecret.encode('utf-8'), signature_origin.encode('utf-8'),
                                 digestmod=hashlib.sha256).digest()
        signature_sha = base64.b64encode(signature_sha).decode(encoding='utf-8')

        authorization_origin = "api_key=\"%s\", algorithm=\"%s\", headers=\"%s\", signature=\"%s\"" % (
            self.APIKey, "hmac-sha256", "host date request-line", signature_sha)
        authorization = base64.b64encode(authorization_origin.encode('utf-8')).decode(encoding='utf-8')
        # 将请求的鉴权参数组合为字典
        v = {
            "authorization": authorization,
            "date": date,
            "host": "iat.xf-yun.com"
        }
        # 拼接鉴权参数，生成url
        url = url + '?' + urlencode(v)
        # print("date: ",date)
        # print("v: ",v)
        # 此处打印出建立连接时候的url,参考本demo的时候可取消上方打印的注释，比对相同参数时生成的url与自己代码生成的url是否一致
        # print('websocket url :', url)
        return url


# 收到websocket消息的处理
def on_message(ws, message):
    message = json.loads(message)
    code = message["header"]["code"]
    status = message["header"]["status"]
    if code != 0:
        print(f"请求错误：{code}")
        ws.close()
    else:
        payload = message.get("payload")
        if payload:
            text = payload["result"]["text"]
            text = json.loads(str(base64.b64decode(text), "utf8"))
            text_ws = text['ws']
            result = ''
            for i in text_ws:
                for j in i["cw"]:
                    w = j["w"]
                    result += w
            print(result)
        if status == 2:
            ws.close()


# 收到websocket错误的处理
def on_error(ws, error):
    print("### error:", error)


# 收到websocket关闭的处理
def on_close(ws, close_status_code, close_msg):
    print("### closed ###")


# 收到websocket连接建立的处理
def on_open(ws):
    def run(*args):
        frameSize = 1280  # 每一帧的音频大小
        intervel = 0.04  # 发送音频间隔(单位:s)
        status = STATUS_FIRST_FRAME  # 音频的状态信息，标识音频是第一帧，还是中间帧、最后一帧

        with open(wsParam.AudioFile, "rb") as fp:
            while True:

                buf = fp.read(frameSize)
                audio = str(base64.b64encode(buf), 'utf-8')

                # 文件结束
                if not buf:
                    status = STATUS_LAST_FRAME
                # 第一帧处理
                if status == STATUS_FIRST_FRAME:

                    d = {"header":
                        {
                            "status": 0,
                            "app_id": wsParam.APPID
                        },
                        "parameter": {
                            "iat": wsParam.iat_params
                        },
                        "payload": {
                            "audio":
                                {
                                    "audio": audio, "sample_rate": 16000, "encoding": "raw"
                                }
                        }}
                    d = json.dumps(d)
                    ws.send(d)
                    status = STATUS_CONTINUE_FRAME
                # 中间帧处理
                elif status == STATUS_CONTINUE_FRAME:
                    d = {"header": {"status": 1,
                                    "app_id": wsParam.APPID},
                         "parameter": {
                             "iat": wsParam.iat_params
                         },
                         "payload": {
                             "audio":
                                 {
                                     "audio": audio, "sample_rate": 16000, "encoding": "raw"
                                 }}}
                    ws.send(json.dumps(d))
                # 最后一帧处理
                elif status == STATUS_LAST_FRAME:
                    d = {"header": {"status": 2,
                                    "app_id": wsParam.APPID
                                    },
                         "parameter": {
                             "iat": wsParam.iat_params
                         },
                         "payload": {
                             "audio":
                                 {
                                     "audio": audio, "sample_rate": 16000, "encoding": "raw"
                                 }}}
                    ws.send(json.dumps(d))
                    break

                # 模拟音频采样间隔
                time.sleep(intervel)


    thread.start_new_thread(run, ())


if __name__ == "__main__":
    # 测试时候在此处正确填写相关信息即可运行

    wsParam = Ws_Param(APPID='', APISecret='',
                       APIKey='',
                       AudioFile=r'')
    websocket.enableTrace(False)
    wsUrl = wsParam.create_url()
    ws = websocket.WebSocketApp(wsUrl, on_message=on_message, on_error=on_error, on_close=on_close)
    ws.on_open = on_open
    ws.run_forever(sslopt={"cert_reqs": ssl.CERT_NONE})

三、接口要求
内容	   说明
请求协议	ws[s]（为提高安全性，强烈推荐wss）
请求地址	中英文语音地址：ws[s]: //iat.xf-yun.com/v1
接口鉴权	签名机制，详情请参照下方接口鉴权
字符编码	UTF-8
响应格式	统一采用JSON格式
开发语言	任意，只要可以向讯飞云服务发起HTTP请求的均可
音频属性	采样率16k或8K、位长16bit、单声道
音频格式	pcm、mp3
音频长度	最长60s

四、接口鉴权
#鉴权方法
通过在请求地址后面加上鉴权相关参数的方式。示例url：

https://iat.xf-yun.com/v1?authorization=YXBpX2tleT0ia2V5eHh4eHh4eHg4ZWUyNzkzNDg1MTlleHh4eHh4eHgiLCBhbGdvcml0aG09ImhtYWMtc2hhMjU2IiwgaGVhZGVycz0iaG9zdCBkYXRlIHJlcXVlc3QtbGluZSIsIHNpZ25hdHVyZT0iUzY2RmVxVEpsdmtkK0tmSmcrYTczQkFhYm9jd1JnMnNjS2ZsT05JOG84MD0i&date=Tue%2C%2014%20May%202024%2008%3A46%3A48%20GMT&host=iat.xf-yun.com
鉴权参数：

参数	类型	必须	说明	示例
host	string	是	请求主机	iat.xf-yun.com
date	string	是	当前时间戳，RFC1123格式	Tue, 14 May 2024 08:46:48 GMT
authorization	string	是	使用base64编码的签名相关信息(签名基于hmac-sha256计算)	参考下方authorization参数生成规则
· date参数生成规则

date必须是UTC+0或GMT时区，RFC1123格式(Tue, 14 May 2024 08:46:48 GMT)。
服务端会对Date进行时钟偏移检查，最大允许300秒的偏差，超出偏差的请求都将被拒绝。

· authorization参数生成规则

1）获取接口密钥APIKey 和 APISecret。
在讯飞开放平台控制台，创建WebAPI平台应用并添加语音听写（流式版）服务后即可查看，均为32位字符串。

2）参数authorization base64编码前（authorization_origin）的格式如下。

api_key="$api_key",algorithm="hmac-sha256",headers="host date request-line",signature="$signature"
其中 api_key 是在控制台获取的APIKey，algorithm 是加密算法（仅支持hmac-sha256），headers 是参与签名的参数（见下方注释）。
signature 是使用加密算法对参与签名的参数签名后并使用base64编码的字符串，详见下方。

注： headers是参与签名的参数，请注意是固定的参数名（"host date request-line"），而非这些参数的值。

3）signature的原始字段(signature_origin)规则如下。

signature原始字段由 host，date，request-line三个参数按照格式拼接成，
拼接的格式为(\n为换行符,’:’后面有一个空格)：

host: $host\ndate: $date\n$request-line
假设

请求url = wss://iat.xf-yun.com/v1
date = Tue, 14 May 2024 08:46:48 GMT
那么 signature原始字段(signature_origin)则为：

host: iat.xf-yun.com
date: Tue, 14 May 2024 08:46:48 GMT
GET /v1 HTTP/1.1
4）使用hmac-sha256算法结合apiSecret对signature_origin签名，获得签名后的摘要signature_sha。

signature_sha=hmac-sha256(signature_origin,$apiSecret)
其中 apiSecret 是在控制台获取的APISecret

5）使用base64编码对signature_sha进行编码获得最终的signature。

signature=base64(signature_sha)
假设

APISecret = secretxxxxxxxx2df7900c09xxxxxxxx	
date = Tue, 14 May 2024 08:46:48 GMT
则signature为

signature=S66FeqTJlvkd+KfJg+a73BAabocwRg2scKflONI8o80=
6）根据以上信息拼接authorization base64编码前（authorization_origin）的字符串，示例如下。

api_key="keyxxxxxxxx8ee279348519exxxxxxxx", algorithm="hmac-sha256", headers="host date request-line", signature="S66FeqTJlvkd+KfJg+a73BAabocwRg2scKflONI8o80="
注： headers是参与签名的参数，请注意是固定的参数名（"host date request-line"），而非这些参数的值。

7）最后再对authorization_origin进行base64编码获得最终的authorization参数。

authorization = base64(authorization_origin)
示例：
https://iat.xf-yun.com/v1?authorization=YXBpX2tleT0ia2V5eHh4eHh4eHg4ZWUyNzkzNDg1MTlleHh4eHh4eHgiLCBhbGdvcml0aG09ImhtYWMtc2hhMjU2IiwgaGVhZGVycz0iaG9zdCBkYXRlIHJlcXVlc3QtbGluZSIsIHNpZ25hdHVyZT0iUzY2RmVxVEpsdmtkK0tmSmcrYTczQkFhYm9jd1JnMnNjS2ZsT05JOG84MD0i&date=Tue%2C%2014%20May%202024%2008%3A46%3A48%20GMT&host=iat.xf-yun.com

五、数据传输接收与请求、返回示例
#1、数据传输接收
握手成功后客户端和服务端会建立Websocket连接，客户端通过Websocket连接可以同时上传和接收数据。
当服务端有识别结果时，会通过Websocket连接推送识别结果到客户端。

发送数据时，如果间隔时间太短，可能会导致引擎识别有误。
建议每次发送音频间隔40ms，每次发送音频字节数（即java示例demo中的frameSize）为一帧音频大小的整数倍。

//连接成功，开始发送数据
int frameSize = 1280; //每一帧音频大小的整数倍，请注意不同音频格式一帧大小字节数不同，可参考下方建议
int intervel = 40;
int status = 0;  // 音频的状态
try (FileInputStream fs = new FileInputStream(file)) {
    byte[] buffer = new byte[frameSize];
    // 发送音频
我们建议：未压缩的PCM格式，每次发送音频间隔40ms，每次发送音频字节数1280B；

#2、请求json示例
第一帧数据：

{
  "header": {
    "app_id": "your_appid",
    "res_id": "hot_words",
    "status": 0
  },
  "parameter": {
    "iat": {
      "domain": "slm",
      "language": "zh_cn",
      "accent": "mandarin",
      "eos": 6000,
      "vinfo": 1,
      "dwa": "wpgs",
      "result": {
        "encoding": "utf8",
        "compress": "raw",
        "format": "json"
      }
    }
  },
  "payload": {
    "audio": {
      "encoding": "raw",
      "sample_rate": 16000,
      "channels": 1,
      "bit_depth": 16,
      "seq": 1,
      "status": 0,
      "audio": "AAAAAP..."
    }
  }
}
中间帧数据：

{
  "header": {
    "app_id": "your_appid",
    "res_id": "hot_words",
    "status": 1
  },
  "payload": {
    "audio": {
      "encoding": "raw",
      "sample_rate": 16000,
      "channels": 1,
      "bit_depth": 16,
      "seq": 2,
      "status": 1,
      "audio": "AAAAAA..."
    }
  }
}
最后一帧数据：

{
  "header": {
    "app_id": "your_appid",
    "res_id": "hot_words",
    "status": 2
  },
  "payload": {
    "audio": {
      "encoding": "raw",
      "sample_rate": 16000,
      "channels": 1,
      "bit_depth": 16,
      "seq": 591,
      "status": 2,
      "audio": ""
    }
  }
}
#3、返回json示例
第一帧返回数据示例：

{
  "header": {
    "code": 0,
    "message": "success",
    "sid": "iat000e0044@hu18f5b16b0330324...",
    "status": 0
  }
}
中间帧返回数据示例：

{
  "header": {
    "code": 0,
    "message": "success",
    "sid": "iat000e0044@hu18f5b16b033032...",
    "status": 1
  },
  "payload": {
    "result": {
      "compress": "raw",
      "encoding": "utf8",
      "format": "json",
      "seq": 2,
      "status": 1,
      "text": "eyJzbiI6Miwib..."
    }
  }
}
最后一帧返回数据示例：

{
  "header": {
    "code": 0,
    "message": "success",
    "sid": "iat000e0044@hu18f5b16b033032...",
    "status": 2
  },
  "payload": {
    "result": {
      "compress": "raw",
      "encoding": "utf8",
      "format": "json",
      "seq": 76,
      "status": 2,
      "text": "eyJzbiI6NzYs..."
    }
  }
}

六、参数说明
#1、请求参数说明
参数名	类型	必传	描述
header	object	是	用于上传平台参数
header.app_id	string	是	在平台申请的appid信息
header.res_id	string	否	应用级热词，用于提高相关词语识别权重（可直接在控制台 设置，并上传res_id）
header.status	int	是	音频传输状态 0:首帧 1：中间帧 2:最后一帧
parameter	object	是	用于上传服务特性参数
parameter.iat	object	是	服务名称，大模型中文语音识别
parameter.iat.domain	string	是	指定访问的领域 slm
parameter.iat.language	string	是	语种 zh_cn
parameter.iat.accent	string	是	方言 mandarin（代表普通话）
parameter.iat.eos	int	否	静音多少秒停止识别 如6000毫秒
parameter.iat.ltc	int	否	是否进行中英文筛选，默认：1，不进行筛选
2，只出中文
3，只出英文
parameter.iat.vinfo	int	否	句子级别帧对齐
parameter.iat.dwa	string	否	动态修正控制：默认关闭
开启（wpgs）：实时返回识别结果，每次返回的结果可能是对之前结果的追加，也有可能是对之前结果的替换（即修正）；
关闭：实时返回识别结果，每次返回的结果都是对之前结果的追加；
开启后返回结果的颗粒度更小，视觉冲击效果更佳；
parameter.iat.dhw	string	否	会话热词，支持utf-8和gb2312；
取值样例：“dhw=gb2312;你好|大家”（对应gb2312编码）；
 “dhw=utf-8;你好|大家”（对应utf-8编码）
最小长度:0, 最大长度:1024
parameter.iat.result	obejct	否	响应数据字段
payload	object	是	请求数据携带
payload.audio	object	是	音频数据模块
payload.audio.encoding	string	否	音频编码 raw或lame（代表pcm和mp3格式）
payload.audio.sample_rate	int	否	音频采样率 16000, 8000
payload.audio.channels	int	否	音频声道 1
payload.audio.bit_depth	int	否	音频位深 16
payload.audio.seq	int	否	数据序号 0-999999
payload.audio.status	int	否	取值范围为：0（开始）、1（继续）、2（结束）
payload.audio.audio	string	是	音频数据base64 音频时长不要超过60秒
#2、返回参数说明
参数名	类型	描述
header	object	协议头部
header.message	string	描述信息
header.code	int	返回码
0表示会话调用成功（并不一定表示服务调用成功，服务是否调用成功以text字段中的ret为准）
其它表示会话调用异常
header.sid	string	本次会话id
header.status	int	数据状态 0:开始, 1:继续, 2:结束
payload	object	数据段，用于携带响应的数据
payload.result.compress	string	文本压缩格式
payload.result.encoding	string	文本编码
payload.result.format	string	文本格式
payload.result.seq	int	数据序号 0-999999
payload.result.status	int	0:开始, 1:继续, 2:结束
payload.result.text	string	听写数据文本 base64编码
text字段base64解码后参数说明请：

参数	类型	描述
sn	int	返回结果的序号
ls	bool	是否是最后一片结果
bg	int	保留字段，无需关心
ed	int	保留字段，无需关心
ws	array	听写结果
ws.bg	int	起始的端点帧偏移值，单位：帧（1帧=10ms）
注：以下两种情况下bg=0，无参考意义：
1)返回结果为标点符号或者为空；2)本次返回结果过长。
ws.cw	array	中文分词
ws.cw.w	string	字词
ws.cw.lg	string	源语种
ws.cw.其他字段
sc/wb/wc/we/wp/ng/ph	int/string	均为保留字段，无需关心。如果解析sc字段，建议float与int数据类型都做兼容
#动态修正返回参数
若开通了动态修正功能并设置了dwa=wpgs（仅中文支持），还有如下字段返回：
注：动态修正结果解析可参考页面下方的java demo。

参数	类型	描述
data.result.pgs	string	开启wpgs会有此字段
取值为 "apd"时表示该片结果是追加到前面的最终结果；取值为"rpl" 时表示替换前面的部分结果，替换范围为rg字段
data.result.rg	array	替换范围，开启wpgs会有此字段
假设值为[2,5]，则代表要替换的是第2次到第5次返回的结果